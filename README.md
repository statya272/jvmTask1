# Задача "Понимание JVM"

## Описание
Просмотрите код ниже и опишите (текстово или с картинками) каждую строку с точки зрения происходящего в JVM  

Не забудьте упомянуть про: 
- ClassLoader'ы, 
- области памяти (стэк (и его фреймы), хип, метаспейс)  
- сборщик мусора

## Код для исследования
```java
public class JvmComprehension {
    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }
    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

## Решение
Выполнение кода начнется с загрузки классов.

Код анализируется, выделяются используемые классы. Направляется запрос на загрузку найденных классов в подсистему загрузки классов.
Она состоит из трех уровней: 
- Bootstrap ClassLoader
- Platform ClassLoader
- Application ClassLoader

Класс JvmComprehension и различные системные классы загружаются в область памяти, которая называется Metaspace

После того, как класссы будут загружены, наступит стадия связывания, состоящая из трех этапов:
- Верификация - проверка валидности кода
- Подготовка - подготовка примитивов в статичских полях
- Разрешение символьных ссылок - связывание ссылок на другие классы

Далее последует этап инициализации, во время которого будут выполнены static инициализаторы и инициализаторы static полей.

При дальнейшем выполнении кода, в памяти будет выделяться место для хранения информации. Для этого существуют две области памяти:
- heap - хранит ссылочные типы
- Stack - хранит примитивные типы данных и ссылки на heap

Разберем выделение памяти построчно:
```java
	public static void main(String[] args) { // Создается фрейм для метода main в Stack
	
	int i = 1; // создается переменная, ей присваивается значение и помещается во фрейм main 

	Object o = new Object(); // в heap создается объект Object. Во фрейм main помещается переменная, хранящая ссылку на этот объект
	
	Integer ii = 2; // в heap создается объект Integer. Во фрейм main помещается переменная, хранящая ссылку на этот объект
	
	printAll(o, i, ii); // создается новый фрейм для метода printAll в Stack. В него помещается переменная o, содержащая ссылку на объект Object, переменная ii , содержащая ссылку на объект Integer и переменная i , которой присваивается значение переменной i из фрейма метода main
	
	Integer uselessVar = 700; // в heap создается объект Integer. Во фрейм printAll помещается переменная uselessVar, хранящая ссылку на этот объект
	
	System.out.println(o.toString() + i + ii); // создается новый фрейм для метода println в Stack. В него помещается переменная i, которой присваивается значение и переменная ii, содержащая ссылку на объект Integer. Создается новый фрейм метода toString со ссылкой на о Object. Фрейм toString удаляется после выполнения. Затем удаляется из стека фрейм метода println
	
	// Удаляетя из стека фрейм метода printAll	
	
	System.out.println("finished"); // создается новый фрейм для метода println в Stack. В него помещается переменная, которой присваивается значение "finished". Фрейм метода println удаляется после выполнения.
	
	// Удаляетя из стека фрейм метода main
```

Во время выполенения кода, сборщик мусора периодисески проверяет heap на наличие объектов, на которые больше нет ссылок (объект больше не используется) и удаляет их.